NumericVector I = 1 + log(1 + i_eps);
NumericVector B = b + log(1 + b_eps);
NumericVector lambda2 = (I - A) / (i_eps - a_eps);
NumericVector lambda3 = (B - I) / (b_eps - i_eps);
NumericMatrix total_prob (p, 4);
total_prob(_, 0) = log(1+a/epsilon);
total_prob(_, 1) = total_prob(_, 0) + (1/lambda2) * exp(-A) * (1 - exp(-(I-A)));
total_prob(_, 2) = total_prob(_, 1) + (1/lambda3) * exp(-I) * (1 - exp(-(B-I)));
total_prob(_, 3) = total_prob(_, 2) + (1/epsilon) * exp(-B);
total_prob(_, 0) = total_prob(_, 0) / total_prob(_, 3);
total_prob(_, 1) = total_prob(_, 1) / total_prob(_, 3);
total_prob(_, 2) = total_prob(_, 2) / total_prob(_, 3);
NumericVector eta(p);
for(int i=0; i<p; ++i){
if(epsilon[i] > 1){
NumericVector v = Rcpp::runif(1, 0, 1);
double z = -log(1 - v[0]) / epsilon[i];
NumericVector u = Rcpp::runif(1, 0, 1);
if(u[0] < (1 / (1 + z))){
eta[i] = z;
} else{
--i;
}
} else {
// NumericVector u = Rcpp::runif(1, 0, 1);
std::uniform_real_distribution<> u(0, 1.0);
NumericVector u_z = Rcpp::runif(1, 0, 1);
double z;
double fl;
if(u < total_prob(i, 0)){
z = exp(u_z[0] * log(1 + a_eps[i]))-1;
fl = log(1 + z);
} else if(u < total_prob(i, 1)){
z = a_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(I[i]-A[i])))/lambda2[i];
fl = A[i] + lambda2[i] * (z - a_eps[i]);
} else if(u < total_prob(i, 2)){
z = i_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(B[i]-I[i])))/lambda3[i];
fl = I[i] + lambda3[i] * (z - b_eps[i]);
} else{
z = b_eps[i] - log(1 - u_z[0])/epsilon[i];
fl = B[i] + epsilon[i] * (z - b_eps[i]);
}
double f = epsilon[i] * z + log(1 + z);
u = Rcpp::runif(1, 0, 1);
if(u[0] < exp(-(f - fl))){
eta[i] = z;
} else{
--i;
}
}
}
return eta;
}
"
sourceCpp(code = src)
src <- "
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
NumericVector rcpp_rejection_sampler(NumericVector epsilon, double a, double b){
int p = epsilon.length();
NumericVector a_eps = a/epsilon;
NumericVector i_eps = 1/epsilon;
NumericVector b_eps = b/epsilon;
NumericVector A = a + log(1 + a_eps);
NumericVector I = 1 + log(1 + i_eps);
NumericVector B = b + log(1 + b_eps);
NumericVector lambda2 = (I - A) / (i_eps - a_eps);
NumericVector lambda3 = (B - I) / (b_eps - i_eps);
NumericMatrix total_prob (p, 4);
total_prob(_, 0) = log(1+a/epsilon);
total_prob(_, 1) = total_prob(_, 0) + (1/lambda2) * exp(-A) * (1 - exp(-(I-A)));
total_prob(_, 2) = total_prob(_, 1) + (1/lambda3) * exp(-I) * (1 - exp(-(B-I)));
total_prob(_, 3) = total_prob(_, 2) + (1/epsilon) * exp(-B);
total_prob(_, 0) = total_prob(_, 0) / total_prob(_, 3);
total_prob(_, 1) = total_prob(_, 1) / total_prob(_, 3);
total_prob(_, 2) = total_prob(_, 2) / total_prob(_, 3);
NumericVector eta(p);
for(int i=0; i<p; ++i){
if(epsilon[i] > 1){
NumericVector v = Rcpp::runif(1, 0, 1);
double z = -log(1 - v[0]) / epsilon[i];
NumericVector u = Rcpp::runif(1, 0, 1);
if(u[0] < (1 / (1 + z))){
eta[i] = z;
} else{
--i;
}
} else {
// NumericVector u = Rcpp::runif(1, 0, 1);
std::uniform_real_distribution<> u(0.0, 1.0);
NumericVector u_z = Rcpp::runif(1, 0, 1);
double z;
double fl;
if(u < total_prob(i, 0)){
z = exp(u_z[0] * log(1 + a_eps[i]))-1;
fl = log(1 + z);
} else if(u < total_prob(i, 1)){
z = a_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(I[i]-A[i])))/lambda2[i];
fl = A[i] + lambda2[i] * (z - a_eps[i]);
} else if(u < total_prob(i, 2)){
z = i_eps[i] - log(1 - u_z[0] + u_z[0]*exp(-(B[i]-I[i])))/lambda3[i];
fl = I[i] + lambda3[i] * (z - b_eps[i]);
} else{
z = b_eps[i] - log(1 - u_z[0])/epsilon[i];
fl = B[i] + epsilon[i] * (z - b_eps[i]);
}
double f = epsilon[i] * z + log(1 + z);
u = Rcpp::runif(1, 0, 1);
if(u[0] < exp(-(f - fl))){
eta[i] = z;
} else{
--i;
}
}
}
return eta;
}
"
sourceCpp(code = src)
message("You chose FALSE for the auto.threshold argument, but since threshold = 0 is set, it defaults to threshold =", 100)
message("You chose FALSE for the auto.threshold argument, but since threshold = 0 is set, it defaults to threshold = ", 100)
message("You chose FALSE for the auto.threshold argument,
but since threshold = 0 is set, it is reset to the default to threshold = ", 100)
message("You chose FALSE for the auto.threshold argument, but since threshold = 0 is set, it is reset to the default to threshold = ", 100)
message("You chose FALSE for the auto.threshold argument, ",
"but since threshold = 0 is set, it is reset to the",
"default to threshold = ", 100)
message("You chose FALSE for the auto.threshold argument, ",
"but since threshold = 0 is set, it is reset to the ",
"default to threshold = ", 100)
apply(rep(1, 1000), 2, quantile, probs = 0.975)
quantile(rep(1, 1000), probs = 0.975)
quantile(rep(1, 1000), probs = 0.975)
?apply
remove.packages("Mhorseshoe")
library(Mhorseshoe)
# making simulation data.
set.seed(123)
N <- 300
p <- 500
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
library(tidyverse)
approx_horseshoe_result <- approx_horseshoe(X, y, iteration = 5000)
approx_horseshoe_result <- approx_horseshoe(X, y, iteration = 5000)
approx_horseshoe_result <- approx_horseshoe(X, y)
#'
#' # Lower bound of the 95% credible interval
#' post_leftCI <- apply(result$BetaSamples, MARGIN = 2,
#'                      quantile, probs = 0.025)
#'
#' # Upper bound of the 95% credible interval
#' post_rightCI <- apply(result$BetaSamples, MARGIN = 2,
#'                       quantile, probs = 0.975)
#'
#' @export
approx_horseshoe <- function(X, y, burn = 1000, iteration = 5000,
auto.threshold = TRUE, threshold = 0, a = 0.2,
b = 10, s = 0.8, tau = 1, sigma2 = 1, w = 1,
alpha = 0.05) {
N <- nrow(X)
p <- ncol(X)
eta <- rep(1, p)
xi <- tau^(-2)
Q <- t(X) %*% X
if (auto.threshold == TRUE) {
S <- p
active_index <- 1:p
m_eff <- p
s2.vec <- diag(Q)
} else if (threshold == 0) {
threshold <- ifelse(p >= N, 1/p, 1/sqrt(N*p))
message("You chose FALSE for the auto.threshold argument. ",
"but since threshold = 0 is set, it is reset to ",
"threshold = ", threshold)
}
betaout <- matrix(0, nrow = iteration, ncol = p)
etaout <- matrix(0, nrow = iteration, ncol = p)
xiout <- rep(0, iteration)
sigma2out <- rep(0, iteration)
activeout <- rep(0, iteration)
nmc <- burn + iteration
# run
for(i in 1:nmc) {
log_xi <- stats::rnorm(1, mean = log(xi), sd = s)
new_xi <- exp(log_xi)
# when to use a fixed threshold
if (auto.threshold == FALSE) {
max_xi <- max(xi, new_xi)
active_index <- which((1 / (eta * max_xi) > threshold))
S <- length(active_index)
}
Q_s <- Q[active_index, active_index, drop = FALSE]
X_s <- X[, active_index, drop = FALSE]
# xi update
if (S < N) {
Xy <- t(X_s) %*% y
y_square <- t(y) %*% y
Q_star <- xi * diag(eta[active_index], nrow = S) + Q_s
m <- solve(Q_star, Xy)
ymy <- y_square - t(y) %*% X_s %*% m
if (s != 0) {
new_Q_star <- new_xi * diag(eta[active_index], nrow = S) + Q_s
new_m <- solve(new_Q_star, Xy)
new_ymy <- y_square - t(y) %*% X_s %*% new_m
cM <- (diag(chol(Q_star))^2) / xi
new_cM <- (diag(chol(new_Q_star))^2) / new_xi
curr_ratio <- -sum(log(cM)) / 2 - ((N + w) / 2) * log(w + ymy) -
log(sqrt(xi) * (1 + xi))
new_ratio <- -sum(log(new_cM)) / 2 - ((N + w) / 2) * log(w + new_ymy) -
log(sqrt(new_xi) * (1 + new_xi))
acceptance_probability <- exp(new_ratio - curr_ratio + log(new_xi) -
log(xi))
u <- stats::runif(n = 1, min = 0, max = 1)
if (u < acceptance_probability) {
xi <- new_xi
ymy <- new_ymy
Q_star <- new_Q_star
}
}
} else {
DX <- (1/eta[active_index]) * t(X_s)
XDX <- X_s %*% DX
M <- diag(N) + XDX/xi
m <- solve(M, y)
ymy <- t(y) %*% m
if (s != 0) {
new_M <- diag(N) + XDX/new_xi
new_m <- solve(new_M, y)
new_ymy <- t(y) %*% new_m
cM <- diag(chol(M))^2
new_cM <- diag(chol(new_M))^2
curr_ratio <- -sum(log(cM))/2 - ((N + w)/2) * log(w + ymy) -
log(sqrt(xi) * (1 + xi))
new_ratio <- -sum(log(new_cM))/2 - ((N + w)/2)*log(w + new_ymy) -
log(sqrt(new_xi) * (1 + new_xi))
acceptance_probability <- exp(new_ratio - curr_ratio + log(new_xi) -
log(xi))
u <- stats::runif(n = 1, min = 0, max = 1)
if (u < acceptance_probability) {
xi <- new_xi
ymy <- new_ymy
M <- new_M
}
}
}
# sigma update
sigma2 <- 1/stats::rgamma(1, shape = (w + N)/2, rate = (w + ymy)/2)
# beta update
diag_D <- 1 / (eta * xi)
u <- stats::rnorm(n = p, mean = 0, sd = sqrt(diag_D))
f <- stats::rnorm(n = N, mean = 0, sd = 1)
v <- X %*% u + f
diag_D[-active_index] <- 0
U <- diag_D * t(X)
if (S < N) {
yv <- y/sqrt(sigma2) - v
Xyv <- t(X_s) %*% yv
m <- solve(Q_star, Xyv)
m_star <- yv - X_s %*% m
new_beta <- sqrt(sigma2) * (u + U %*% m_star)
} else {
v_star <- solve(M, (y/sqrt(sigma2) - v))
new_beta <- sqrt(sigma2) * (u + U %*% v_star)
}
# save results
betaout[i, ] <- new_beta
etaout[i, ] <- eta
xiout[i] <- xi
sigma2out[i] <- sigma2
activeout[i] <- S
# eta update
eta <- rejection_sampler((new_beta^2)*xi/(2*sigma2), a, b)
eta <- ifelse(eta <= 2.220446e-16, 2.220446e-16, eta)
# when use a auto threshold
if (auto.threshold == TRUE) {
if (i %% t == 0) {
u_i <- stats::runif(1, 0, 1)
p_i <- exp(alpha0 + alpha1 * i)
if (u_i < p_i) {
m_eff <- sum(1/((eta*xi)/s2.vec + 1))
}
}
threshold <- sort(eta)[ceiling(m_eff)]
active_index <- which(eta <= threshold)
S <- length(active_index)
}
}
betaout <- betaout[(burn+1):nmc, ]
lambdaout <- 1/sqrt(etaout[(burn+1):nmc, ])
tauout <- 1/sqrt(xiout[(burn+1):nmc])
sigma2out <- sigma2out[(burn+1):nmc]
activeout <- activeout[(burn+1):nmc]
betahat <- apply(betaout, 2, mean)
lambdahat <- apply(lambdaout, 2, mean)
tauhat <- mean(tauout)
sigma2hat <- mean(sigma2out)
activemean <- mean(activeout)
leftci <- apply(result$BetaSamples, 2, stats::quantile, probs = 0.025)
rightci <- apply(result$BetaSamples, 2, stats::quantile, probs = 0.975)
result <- list(BetaHat = betahat, LeftCI = leftci, RightCI = rightci,
Sigma2Hat = sigma2hat, TauHat = tauhat, LambdaHat = lambdahat,
ActiveMean = activemean, BetaSamples = betaout,
LambdaSamples = lambdaout, TauSamples = tauout,
Sigma2Samples = sigma2out, NumOfActive = activeout)
return(result)
}
remove.packages("Mhorseshoe")
library(Mhorseshoe)
library(tidyverse)
# making simulation data.
set.seed(123)
N <- 300
p <- 500
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
approx_horseshoe_result <- approx_horseshoe(X, y)
remove.packages("Mhorseshoe")
library(Mhorseshoe)
library(tidyverse)
# making simulation data.
set.seed(123)
N <- 300
p <- 500
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
approx_horseshoe_result <- approx_horseshoe(X, y)
remove.packages("Mhorseshoe")
library(Mhorseshoe)
library(tidyverse)
library(tictoc)
# making simulation data.
set.seed(123)
N <- 300
p <- 500
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
tic()
approx_horseshoe_result <- approx_horseshoe(X, y)
remove.packages("Mhorseshoe")
library(Mhorseshoe)
library(tidyverse)
library(tictoc)
# making simulation data.
set.seed(123)
N <- 300
p <- 500
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
tic()
approx_horseshoe_result <- approx_horseshoe(X, y)
toc()
approx_horseshoe_result$BetaHat
approx_horseshoe_result$LeftCI
approx_horseshoe_result$RightCI
approx_horseshoe_result$Sigma2Hat
approx_horseshoe_result$TauHat
approx_horseshoe_result$LambdaHat
approx_horseshoe_result$ActiveMean
dim(approx_horseshoe_result$BetaSamples)
dim(approx_horseshoe_result$LambdaSamples)
dim(approx_horseshoe_result$TauSamples)
approx_horseshoe_result$TauSamples
approx_horseshoe_result$Sigma2Samples
approx_horseshoe_result$NumOfActive
approx_horseshoe_result$ActiveMean
tic()
approx_horseshoe_result2 <- approx_horseshoe(X, y, auto.threshold = FALSE)
toc()
approx_horseshoe_result2$BetaHat
approx_horseshoe_result2$LeftCI
approx_horseshoe_result2$RightCI
approx_horseshoe_result2$Sigma2Hat
approx_horseshoe_result2$TauHat
approx_horseshoe_result2$LambdaHat
approx_horseshoe_result2$ActiveMean
library(horseshoe)
tic()
horseshoe_result <- horseshoe(y, X, method.tau = "halfCauchy", method.sigma = "Jeffreys")
toc()
# making simulation data.
set.seed(123)
N <- 500
p <- 5000
p_star <- 50
true_beta <- c(rep(1, p_star), rep(0, p-p_star))
# design matrix X.
X <- matrix(1, nrow = N, ncol = p)
for (i in 1:p) {
X[, i] <- stats::rnorm(N, mean = 0, sd = 1)
}
# response variable y.
y <- vector(mode = "numeric", length = N)
e <- rnorm(N, mean = 0, sd = 2)
for (i in 1:p_star) {
y <- y + true_beta[i] * X[, i]
}
y <- y + e
tic() # 70.31
approx_horseshoe_result <- approx_horseshoe(X, y, iteration = 1000)
toc()
approx_horseshoe_result$BetaHat
approx_horseshoe_result$TauHat
approx_horseshoe_result$LambdaHat
approx_horseshoe_result$ActiveMean # 209
tic() # 75.75
approx_horseshoe_result2 <- approx_horseshoe(X, y, iteration = 1000,
auto.threshold = FALSE)
toc()
approx_horseshoe_result2$BetaHat
approx_horseshoe_result2$ActiveMean # 218
approx_horseshoe_result2$TauHat
approx_horseshoe_result2$LambdaHat
tic() # 151.3
horseshoe_result <- horseshoe(y, X, method.tau = "halfCauchy", method.sigma = "Jeffreys",
nmc = 1000)
toc()
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
install.packages("xaringan")
library(Mhorseshoe)
?approx_horseshoe
?approx_horseshoe
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
?rejection_sampler
remove.packages("Mhorseshoe")
library(Mhorseshoe)
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
?horseshoe::horseshoe
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
?exact_horseshoe
?approx_horseshoe
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
?Mhorseshoe
?approx_horseshoe
remove.packages("Mhorseshoe")
library(Mhorseshoe)
?approx_horseshoe
remove.packages("Mhorseshoe")
